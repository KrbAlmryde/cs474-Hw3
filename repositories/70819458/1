From c0ef95dfdaced28ceef15a2b8b9eea2918b28460 Mon Sep 17 00:00:00 2001
From: Flavia <flaviabrogle@hotmail.com>
Date: Wed, 9 Nov 2016 03:02:03 +0100
Subject: [PATCH] GameOfLife Done


-	-	Blatt 7/Blatt7.pdf
16	0	Blatt 7/Game of Life/BasicGOL.java
124	0	Blatt 7/Game of Life/GameOfLife.java
72	0	Blatt 7/Mandelbrot/ColorPalette.java
38	0	Blatt 7/Mandelbrot/Complex.java
57	0	Blatt 7/Mandelbrot/Mandelbrot.java
401	0	Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindow.java
33	0	Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindowMouseListener.java
36	0	Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/KeyListener.java
 create mode 100644 Blatt 7/Blatt7.pdf
 create mode 100644 Blatt 7/Game of Life/BasicGOL.java
 create mode 100644 Blatt 7/Game of Life/GameOfLife.java
 create mode 100644 Blatt 7/Mandelbrot/ColorPalette.java
 create mode 100644 Blatt 7/Mandelbrot/Complex.java
 create mode 100644 Blatt 7/Mandelbrot/Mandelbrot.java
 create mode 100644 Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindow.java
 create mode 100644 Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindowMouseListener.java
 create mode 100644 Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/KeyListener.java

diff --git a/Blatt 7/Blatt7.pdf b/Blatt 7/Blatt7.pdf
new file mode 100644
index 0000000..402c1c4
Binary files /dev/null and b/Blatt 7/Blatt7.pdf differ
diff --git a/Blatt 7/Game of Life/BasicGOL.java b/Blatt 7/Game of Life/BasicGOL.java
new file mode 100644
index 0000000..0cb4484
--- /dev/null
+++ b/Blatt 7/Game of Life/BasicGOL.java	
@@ -0,0 +1,16 @@
+public class BasicGOL {
+	
+	public static void main (String[] args) throws InterruptedException {
+		
+		GameOfLife gol = new GameOfLife(6);
+		
+		while (true) {
+			System.out.println(gol.toString());
+			Thread.sleep(500);
+			if(gol.update() == false) break;
+		}
+		System.out.println(gol.toString());
+		
+	}
+	
+}
\ No newline at end of file
diff --git a/Blatt 7/Game of Life/GameOfLife.java b/Blatt 7/Game of Life/GameOfLife.java
new file mode 100644
index 0000000..088c54b
--- /dev/null
+++ b/Blatt 7/Game of Life/GameOfLife.java	
@@ -0,0 +1,124 @@
+import java.util.Random;
+
+public class GameOfLife {
+	
+	// PROPERTIES
+	
+	boolean[][] population;
+	int size;
+	
+	
+	// INITIALIZER
+	
+	public GameOfLife (int size) {
+		this.size = size;
+		population = new boolean[size][size];
+		Random r = new Random();
+		for (int i = 0; i < size; i++) {
+			for (int j = 0; j < size; j++) {
+				if (r.nextInt(100) < 30) population[i][j] = true;
+			}
+		}
+	}
+	
+	public GameOfLife () {
+		size = 6;
+		population = new boolean[size][size];
+		population[1][1] = true;
+		population[1][3] = true;
+		population[2][2] = true;
+		population[2][3] = true;
+		population[3][2] = true;
+	}
+	
+	
+	// METHODS
+	
+	public boolean getFieldAt(int x, int y) {
+		// If the variables are out of bounds bring them back in so we don't have to worry
+		// about the bounds when checking the neighbours.
+		while (x < 0) 		{ x += size; }
+		while (x >= size) 	{ x -= size; }
+		while (y < 0) 		{ y += size; }
+		while (y >= size) 	{ y -= size; }
+		
+		return population[x][y];
+	}
+	
+	public int countNeighbours(int x, int y) {
+		int neighbours = 0;
+		
+		// Count every neighbouring cell if it is alive. (the getFieldAt() Method should
+		// take care of the case that the cell is at the edge of the field.
+		for (int i = x-1; i <= x+1; i++) {
+			for (int j = y-1; j <= y+1; j++) {
+				if (getFieldAt(i,j)) neighbours++;
+			}
+		}
+		
+		// We also counted the cell itself, which isn't actually a neighbour.
+		// To fix this we should subtract one if the cell is alive.
+		if (getFieldAt(x,y)) neighbours--;
+		
+		// For bugfinding 
+		// System.out.println("Neighbours for (" + x + ", " + y + "): " + neighbours );
+		
+		return neighbours;
+	}
+	
+	/**
+	 * Updates the Game according to the rules and returns true if it changed,
+	 * false if the game stayed the same after the update.
+	 */
+	public boolean update() {
+		// We have to save it first in a new array so we can check every cell and
+		// set them accordingly in the newPopulation.
+		boolean[][] newPopulation = new boolean[size][size];
+		
+		for (int x = 0; x < size; x++) {
+			for (int y = 0; y < size; y++) {
+				if (countNeighbours(x,y) == 3 || (population[x][y] && countNeighbours(x,y) == 2)) {
+					newPopulation[x][y] = true;
+				} else {
+					newPopulation[x][y] = false;
+				}
+			}
+		}
+		
+		boolean isDifferent = GameOfLife.isDifferent(population, newPopulation);
+		population = newPopulation;
+		return isDifferent;
+	}
+	
+	public String toString() {
+		String out = "";
+		for (int x = 0; x < size; x++) {
+			for (int y = 0; y < size; y++) {
+				if (population[x][y]) {
+					out += "@";
+				} else {
+					out += ".";
+				}
+			}
+			out += "\n";
+		}
+		return out;
+	}
+	
+	public static boolean isDifferent(boolean[][] populationA, boolean[][] populationB) {
+		if (populationA.length != populationB.length) return true;
+		for (int x = 0; x < populationA.length; x++) {
+			for (int y = 0; y < populationA.length; y++) {
+				if (populationA[x][y] != populationB[x][y]) return true;
+			}
+		}
+		return false;
+	}
+	
+}
+
+
+
+
+
+
diff --git a/Blatt 7/Mandelbrot/ColorPalette.java b/Blatt 7/Mandelbrot/ColorPalette.java
new file mode 100644
index 0000000..ff04ce5
--- /dev/null
+++ b/Blatt 7/Mandelbrot/ColorPalette.java	
@@ -0,0 +1,72 @@
+import java.awt.*;
+
+/**
+ * Created by forster on 29.10.14.
+ */
+class ColorPalette {
+
+  Color[] colors;
+
+  // Durch den Konstruktor wird eine der vordefinierten Paletten gewählt.
+  public ColorPalette (int pal) {
+    init(pal);
+  }
+
+  // Vordefinierte Farbpaletten (kann geändert oder erweitert werden).
+  final int[][][] colorPalette = {
+    {
+      {18, 0, 10, 20}, {18, 50, 100, 240}, {18, 20, 3, 26}, {18, 230, 60, 20}, {18, 25, 10, 9},
+      {18, 230, 170, 0}, {18, 20, 40, 10}, {18, 0, 100, 0}, {18, 5, 10, 10}, {18, 210, 70, 30},
+      {18, 90, 0, 50}, {18, 180, 90, 120}, {18, 0, 20, 40}, {18, 30, 70, 200}
+    },
+    {
+      {32, 0, 0, 0},{32, 0, 0, 255},{32,0,255,0},{32,255,255,0},{32,255,0,0}
+    }
+  };
+
+  void init(int palette) {
+
+    // Erstell je nach Palette eine Anzahl Farben.
+    int n = 0;
+    for (int i = 0; i < colorPalette[palette].length; i++)
+      n += colorPalette[palette][i][0];
+    colors = new Color[n];
+    n = 0;
+
+    // Interpolier Farben zwischen je zwei Nachbarn in der Palette.
+    for (int i = 0; i < colorPalette[palette].length; i++) {
+      int[] col1 = colorPalette[palette][i];
+      int[] col2 = colorPalette[palette][(i + 1) % colorPalette[palette].length];
+
+      // Lineare interpolation der RGB Farben.
+      for (int j = 0; j < col1[0]; j++)
+        colors[n + j] = new Color(
+          (col1[1] * (col1[0] - 1 - j) + col2[1] * j) / (col1[0] - 1),
+          (col1[2] * (col1[0] - 1 - j) + col2[2] * j) / (col1[0] - 1),
+          (col1[3] * (col1[0] - 1 - j) + col2[3] * j) / (col1[0] - 1));
+      n += col1[0];
+    }
+  }
+
+  // Berechnet eine Farbe anhand einer Zahl
+  public Color color(int count) {
+    int palSize = colors.length;
+    Color color = colors[(count / 256) % palSize];
+    Color color2 = colors[(count / 256 + palSize - 1) % palSize];
+    int k1 = count % 256;
+    int k2 = 255 - k1;
+    int red = (k1 * color.getRed() + k2 * color2.getRed()) / 255;
+    int green = (k1 * color.getGreen() + k2 * color2.getGreen()) / 255;
+    int blue = (k1 * color.getBlue() + k2 * color2.getBlue()) / 255;
+    color = new Color(red, green, blue);
+    return color;
+  }
+
+  // Berechnet eine Farbe anhand einem Integer und einer komplexen Zahl.
+  public Color getColor(int count, Complex c) {
+    double diff = 0.00000001;
+    int ret = 256*count + (int)(255.0 * Math.log(4 / (c.abs_sqr()+diff)) / Math.log(c.abs_sqr()) / (c.abs_sqr()+diff));
+    return (0>ret) ? color(0) : color(ret);
+  }
+
+}
diff --git a/Blatt 7/Mandelbrot/Complex.java b/Blatt 7/Mandelbrot/Complex.java
new file mode 100644
index 0000000..d1613d6
--- /dev/null
+++ b/Blatt 7/Mandelbrot/Complex.java	
@@ -0,0 +1,38 @@
+/* Die Komplexen Zahlen a+b i, mit (a+bi)+(c+di) = (a+c)+(b+d)i und (a+bi)(c+di) = (ac-bd)+(ad+bc)i */
+class Complex {
+
+  /* Definieren Sie hier die Daten der Klasse */
+	
+
+  /* Der Konstruktor */
+  public Complex(double a, double b) { 
+    /* Implementieren */
+  }
+
+  /* Zugriff auf den realen Anteil */
+  // public double real() { /* Implementieren */ }
+
+  /* Zugriff auf den imaginaeren Anteil */
+  // public double imag() { /* Implementieren */ }
+
+  /* Multiplikation ohne Veraenderung der beteiligten Objekte */
+  // public Complex mult(Complex o) {/* Implementieren */ }
+
+  /* Multiplikation mit Veraenderung der beteiligten Objekte. Gibt this zurueck */
+  // public Complex mult_inplace(Complex o) {/* Implementieren */ }
+
+  /* Das Quadrat (c^2 = c*c) ohne Veraenderung der beteiligten Objekte */
+  // public Complex sqr() { /* Implementieren */ }
+
+  /* Das Quadrat (c^2 = c*c) in place. Veraendert das Objekt und gibt this zurueck. */
+  // public Complex sqr_inplace() { /* Implementieren */  }
+
+  /* Das Quadrat des Betrags */
+  // public double abs_sqr() { /* Implementieren */ }
+
+  /* Addition zweier komplexer Zahlen ohne Veraenderung der beteiligten Objekte */
+  // public Complex add(Complex c) {     /* Implementieren */   }
+
+  /* Addition zweier komplexer Zahlen mit Veraenderung der beteiligten Objekte */
+  // public Complex add_inplace(Complex c) {    /* Implementieren */   }
+}
diff --git a/Blatt 7/Mandelbrot/Mandelbrot.java b/Blatt 7/Mandelbrot/Mandelbrot.java
new file mode 100644
index 0000000..f1c9233
--- /dev/null
+++ b/Blatt 7/Mandelbrot/Mandelbrot.java	
@@ -0,0 +1,57 @@
+import ch.unibas.informatik.cs101.ImageWindow;
+import java.awt.Color;
+
+public class Mandelbrot {
+
+  ColorPalette colPal;
+  int width;
+  int height;
+  ImageWindow sourceWindow;
+
+
+  public static void main(String[] args) {
+    int palette = Integer.parseInt(args[0]);
+    double fact = Double.parseDouble(args[1]);
+    long startTime = 0, endTime;
+    int width = (int) Math.round(64 * fact);
+    int height = (int) Math.round(48 * fact);
+
+    Mandelbrot m1 = new Mandelbrot( width, height, palette);
+    m1.show_mandelbrot(new Complex(-2.5, -1.3), 0.05/fact, 1000);
+    //m1.show_mandelbrot_inplace(new Complex(-2.5, -1.3), 0.05/fact, 255);
+
+    Mandelbrot m2 = new Mandelbrot( width, height, palette);
+    m2.show_mandelbrot(new Complex(-0.755, -0.1), 0.0002/fact, 1000);
+    //m2.show_mandelbrot_inplace(new Complex(-0.755, -0.1), 0.0002/fact, 1000);
+  }
+
+
+  public Mandelbrot(int _width, int _height, int pal) {
+    width = _width;
+    height = _height;
+    sourceWindow= new ImageWindow(width,height);
+    sourceWindow.openWindow("mandelbrot",0,0);
+    colPal = new ColorPalette(pal);
+  }
+
+  void show_mandelbrot(Complex c_origin, double c_step, int max_iter) {
+    /* Implementieren des Mandelbrot Algorithmus */
+
+    // Color col = colPal.getColor(n,z);
+
+    redraw();
+  }
+
+  void show_mandelbrot_inplace(Complex c_origin, double c_step, int max_iter) {
+    /* Implementieren des Mandelbrot Algorithmus */
+
+    // Color col = colPal.getColor(n,z);
+
+    redraw();
+  }
+
+  public void redraw() {
+    sourceWindow.redraw();
+  }
+
+}
diff --git a/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindow.java b/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindow.java
new file mode 100644
index 0000000..8694c35
--- /dev/null
+++ b/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindow.java	
@@ -0,0 +1,401 @@
+package ch.unibas.informatik.cs101;
+
+import java.awt.AWTException;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.IllegalComponentStateException;
+import java.awt.MouseInfo;
+import java.awt.Point;
+import java.awt.Robot;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+import javax.imageio.ImageIO;
+import javax.swing.JFrame;
+
+/**
+ * A class that manages a java swing window, allowing
+ * for easy manipulation of a framebuffer as well
+ * as mouse and keyboard polling.
+ * @author matthias
+ *
+ */
+@SuppressWarnings("serial")
+public class ImageWindow extends Component {
+	
+
+	/**
+	 * the simulated framebuffer 
+	 */
+	private BufferedImage _image;
+	/**
+	 * the java2D graphics context of above framebuffer
+	 */
+	private Graphics2D  _imageGraphics;
+	/**
+	 * the Swing window this class manages
+	 */
+	private JFrame _jFrame;
+	/**
+	 * listener class for mouse actions
+	 */
+	private ImageWindowMouseListener _imageWindowMouseListener;
+	/**
+	 * listener class for keyboard actions
+	 */
+	private KeyListener _keyListener;
+
+	
+	
+	/**
+	 * Creates a new instance of the ImageWindow class
+	 * @param width the width of the paint (image) area
+	 * @param height the height of the paint (image) area
+	 */
+	public ImageWindow(int width, int height) {
+		_image= new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
+		_imageGraphics=(Graphics2D)_image.getGraphics();
+		_imageWindowMouseListener= new ImageWindowMouseListener();
+		_keyListener = new KeyListener();
+		clearImage();
+	}
+	/**
+	 * Resizes the paint (image) area to the given size. Also resizes the
+	 * window border around it.<br>The old paint area will be copied to the
+	 * new paint area and clipped if necessary.
+	 * @param newWidth the resized width of the paint area
+	 * @param newHeight the resized height of the paint area
+	 */
+	public void resizeImage(int newWidth,int newHeight) {
+		BufferedImage newImage = new BufferedImage(newWidth,newHeight,BufferedImage.TYPE_INT_ARGB);
+		newImage.getGraphics().setColor(new Color(255,255,255,255));
+		((Graphics2D)(newImage.getGraphics())).fill(new Rectangle2D.Float(0, 0,newWidth,newHeight));
+		newImage.getGraphics().drawImage(_image, 0,0,null);
+		_image=newImage;
+		_imageGraphics=(Graphics2D)_image.getGraphics();
+		_jFrame.pack();
+	}
+	/**
+	 * Resets the image to the color white.
+	 */
+	public void clearImage() {
+		 fillImage(255, 255, 255);
+	}
+	/**
+	 * Fills the image with the color values given.
+	 * @param red the red part of the color 0-255
+	 * @param green the green part of the color 0-255
+	 * @param blue the blue part of the color 0-255
+	 */
+	public void fillImage(int red,int green,int blue){
+		 Color color = new Color(red, green, blue, 255);
+		  _imageGraphics.setColor(color);
+		  _imageGraphics.fill(new Rectangle2D.Float(0, 0, _image.getWidth(),_image.getHeight()));
+	}
+	
+	/**
+	 * Loads images from file and copies it to the framebuffer.
+	 * Supports BMP, GIF, JPEG, PNG, TIFF and maybe even some others.
+	 * @param filePath the path, including the filename to the image to be loaded
+	 */
+	public void loadImage(String filePath) {
+		File imageFile= new File(filePath);
+		if (!imageFile.exists()) {
+			System.err.println("File not found: "+filePath);
+		}
+		try {
+			//load image
+			BufferedImage img = ImageIO.read(imageFile);
+			//draw image
+			_imageGraphics.drawImage(img, 0, 0, null);
+		} catch (IOException e) {
+			e.printStackTrace();
+		} 
+	}
+	/**
+	 * Sets a pixel to the given color value. 
+	 * The x and y coordinates are horizontal and vertical positions in the image.<br>
+	 * The (0,0) pixel is located at the top left corner of the image, whereas
+	 * the (image_width-1,image_height-1) pixel is located at the bottom right corner.
+	 * @param x the x position of the pixel
+	 * @param y the y position of the pixel
+	 * @param red the red part of the color 0-255
+	 * @param green the green part of the color 0-255
+	 * @param blue the blue part of the color 0-255
+	 */
+	public void setPixel(int x,int y,int red,int green,int blue) {
+		try {
+			_image.setRGB(x, y,  new Color(red, green, blue).getRGB());
+		} catch (ArrayIndexOutOfBoundsException e) {
+			//someone painted outside the window: do nothing
+		}
+	}
+	
+	/**
+	 * Returns the color of the image at the specified position
+	 * @param x the x position of the pixel
+	 * @param y the y position of the pixel
+	 * @return a java.awt.Color object; i.e. the red channel can be read like this
+	 * from the object : object.getRed()
+	 */
+	public Color getPixel(int x, int y) {
+		try {
+			return new Color(_image.getRGB(x, y));
+		} catch (ArrayIndexOutOfBoundsException e) {
+			//return white if outside
+			return new Color(255,255,255,255);
+		}
+	}
+	/**
+	 * Return the red part of the RGB color at the specified location
+	 * @param x the x position of the pixel
+	 * @param y the y position of the pixel
+	 * @return the red part of the color (int from 0 - 255)
+	 */
+	public int getPixelRed(int x, int y) {
+		return getPixel(x,y).getRed();
+	}
+	/**
+	 * Return the blue part of the RGB color at the specified location
+	 * @param x the x position of the pixel
+	 * @param y the y position of the pixel
+	 * @return the blue part of the color (int from 0 - 255)
+	 */
+	public int getPixelBlue(int x, int y) {
+		return getPixel(x,y).getBlue();
+	}
+	/**
+	 * Return the green part of the RGB color at the specified location
+	 * @param x the x position of the pixel
+	 * @param y the y position of the pixel
+	 * @return the red green of the color (int from 0 - 255)
+	 */
+	public int getPixelGreen(int x, int y) {
+		return getPixel(x,y).getGreen();
+	}
+
+        /**
+         * Set the color of the graphics environment.
+         * Set the color for the further drawings. The value are
+         * passed as integers for the red, green and blue component.
+         * @param r the red part of the color 0-255
+         * @param g the green part of the color 0-255
+         * @param b the blue part of the color 0-255
+         */
+        public void setColor(int r, int g, int b) {
+                _imageGraphics.setColor(new Color(r,g,b,255));
+        }
+        /**
+         * Draws a line between two coordinates.
+         * Daws a line from the point specified by the x- and y-
+         * coordinate to an endpoint specified too by coordinates.
+         * @param xfrom the x coordinate of the startpoint
+         * @param yfrom the y coordinate of the startpoint
+         * @param xto the x coordinate of the endpoint
+         * @param yto the y coordinate of the endpoint
+         */
+        public void drawLine(int xfrom, int yfrom, int xto, int yto) {
+                _imageGraphics.drawLine(xfrom,yfrom,xto,yto);
+        }
+
+	/**
+	 * Opens the window at the x,y location on screen with the given
+	 * Windowname
+	 * @param windowName the windowname
+	 * @param x x-position on screen
+	 * @param y y-position on screen
+	 */
+	public void openWindow(String windowName, int x, int y) {
+		if (_jFrame != null) {
+			_jFrame.dispose();
+		}
+		_jFrame = new JFrame(windowName);
+		_jFrame.addWindowListener(new WindowAdapter() {
+			public void windowClosing(WindowEvent e) {
+				if (_jFrame!=null) {
+					_jFrame.dispose();
+					_jFrame=null;
+				}
+			}
+		});
+		this.addMouseListener(_imageWindowMouseListener);
+		_jFrame.setLocation(x, y);
+		_jFrame.addKeyListener(_keyListener);
+		_jFrame.add(this);
+		_jFrame.pack();
+		_jFrame.setVisible(true);
+		
+		
+	}
+	/**
+	 * Opens the image window.
+	 */
+	public void openWindow() {
+		openWindow("ImageWindow",0,0);
+	}
+	/**
+	 * Closes the image window.
+	 */
+	public void closeWindow() {
+		if (_jFrame==null) return;
+		_jFrame.dispose();
+		_jFrame=null;
+	}
+	/**
+	 * Checks whether the window is currently open or closed
+	 * @return the window open state
+	 */
+	public boolean isWindowOpen() {
+		if (_jFrame==null) return false;
+		return true;
+	}
+	/**
+	 * Forces swing to redraw the current image
+	 */
+	public synchronized void redraw() {
+		if (_jFrame != null) {
+			_jFrame.repaint();
+		} 
+	}
+	/**
+	 * Returns the x pixel position of the mouse in relation
+	 * to the top left image pixel.<br>  
+	 * If the ImageWindow is not open -1,-1 is returned
+	 * @return the x position of the mouse
+	 */
+	public int getMouseXPos() {
+		return getMousePos().x;
+	}
+	/**
+	 * Returns the y pixel position of the mouse in relation
+	 * to the top left image pixel.<br> 
+	 * If the ImageWindow is not open -1,-1 is returned
+	 * @return the y position of the mouse
+	 */
+	public int getMouseYPos() {
+		return getMousePos().y;
+	}
+	/**
+	 * Returns the mouse coordinates relative to the image.<br> 
+	 * If the ImageWindow is not open -1,-1 is returned
+	 * @return java.awt.Point
+	 */
+	public Point getMousePos() {
+		try {
+			Point mousePoint=MouseInfo.getPointerInfo().getLocation();
+			Point componentPoint=this.getLocationOnScreen();
+			Point p = new Point(mousePoint.x-componentPoint.x,mousePoint.y-componentPoint.y);
+			return p;
+		} catch (IllegalComponentStateException e) {
+			return new Point (-1,-1);
+		}
+	}
+	
+	/**
+	 * Moves the mouse pointer to the x,y location (relative to the image)
+	 * This might not work on all platforms as stated in the corresponding 
+	 * javadoc:
+	 * "Note that some platforms require special privileges or extensions to 
+	 * access low-level input control. If the current platform configuration 
+	 * does not allow input control, an AWTException will be thrown when trying 
+	 * to construct Robot objects. For example, X-Window systems will throw the 
+	 * exception if the XTEST 2.2 standard extension is not supported (or not 
+	 * enabled) by the X server."
+	 * 
+	 * @param x the x Position of the mouse
+	 * @param y the y Position of the mouse
+	 */
+	public void setMousePos(int x, int y) {
+		Robot robot;
+		Point imageLocation=this.getLocationOnScreen();	
+		try {
+			robot = new Robot();
+			robot.mouseMove(imageLocation.x+x, imageLocation.y+y);
+		} catch (AWTException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		
+	}
+	/**
+	 * Checks whether the left mouse button is currently pressed.<br>
+	 * Note this only works accurately if the mouse is over the image.
+	 * @return the left mouse button state
+	 */
+	public boolean mousePressed() {
+		return _imageWindowMouseListener.mousePressed();
+	}
+	
+	/**
+	 * Checks whether the key with the corresponding keycode is
+	 * currently held down (pressed).
+	 * @param keyCode the keycode of the key. <br>Use constants from java.awt.event.KeyEvent.<br>
+	 * Letters and number are <br>KeyEvent.VK_A - KeyEvent.VK_Z and KeyEvent.VK_0 - KeyEvent.VK_9
+	 * <br>More constants are defined in the <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/awt/event/KeyEvent.html">
+	 * Key Event</a> javadoc.
+	 * @return whether the key is currently epressed (true) or not (false)
+	 */
+	public boolean isKeyDown(int keyCode) {
+    	return _keyListener.isKeyDown(keyCode);
+    }
+	
+	/**
+	 * Pauses this Thread for the number of milliseconds
+	 * @param milliseconds the pause length
+	 */
+	public void pause(long milliseconds) {
+		try {
+			Thread.sleep(milliseconds);
+		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+	
+	/**
+	 * Returns the current width of the image in pixels.
+	 * @return the width of the image in pixels
+	 */
+	public int getImageWidth() {
+		return _image.getWidth();
+	}
+	
+	/**
+	 * Returns the current height of the image in pixels.
+	 * @return the height of the image in pixels
+	 */
+	public int getImageHeight() {
+		return _image.getHeight();
+	}
+	//functions needed by java from this component 
+	
+	/*
+	 * needed by java to paint this window (should not be
+	 * called directly)
+	 * (non-Javadoc)
+	 * @see java.awt.Component#paint(java.awt.Graphics)
+	 */
+	public void paint (Graphics g) {
+		g.drawImage(_image,0,0,null);	
+	}
+	/*
+	 * needed by java to place this window correctly
+	 * (non-Javadoc)
+	 * @see java.awt.Component#getPreferredSize()
+	 */
+	public Dimension getPreferredSize() {
+		return new Dimension(_image.getWidth(),_image.getHeight());
+	}
+
+        public void setImage(BufferedImage img) {
+	    _imageGraphics.drawImage(img, 0, 0, null);
+        }
+
+}
diff --git a/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindowMouseListener.java b/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindowMouseListener.java
new file mode 100644
index 0000000..15b9192
--- /dev/null
+++ b/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/ImageWindowMouseListener.java	
@@ -0,0 +1,33 @@
+package ch.unibas.informatik.cs101;
+
+import java.awt.event.MouseEvent;
+
+import javax.swing.event.MouseInputAdapter;
+
+public class ImageWindowMouseListener extends MouseInputAdapter {
+
+	private boolean _mousePressed=false;
+	private boolean _mouseInside=false;
+	protected ImageWindowMouseListener() {
+
+	}
+	public void mousePressed(MouseEvent e) {
+		_mousePressed=true;
+	}
+
+	public void mouseReleased(MouseEvent e) {
+		_mousePressed=false;
+	}
+
+	public void mouseEntered(MouseEvent e) {
+		_mouseInside=true;		
+	}
+
+	public void mouseExited(MouseEvent e) {
+		_mouseInside=false;
+	}
+
+	protected boolean mousePressed() {
+		return _mousePressed & _mouseInside;
+	}
+}
diff --git a/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/KeyListener.java b/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/KeyListener.java
new file mode 100644
index 0000000..7f6f33b
--- /dev/null
+++ b/Blatt 7/Mandelbrot/ch/unibas/informatik/cs101/KeyListener.java	
@@ -0,0 +1,36 @@
+package ch.unibas.informatik.cs101;
+
+import java.awt.event.KeyAdapter;
+import java.awt.event.KeyEvent;
+
+public class KeyListener extends KeyAdapter {
+
+	boolean[] _keyDown = new boolean[65536];
+	public KeyListener() {
+
+		
+	}
+	
+	public void keyTyped(KeyEvent e) {
+		//System.out.println("k "+e);
+	}
+    /**
+     * Invoked when a key has been pressed.
+     */
+    public void keyPressed(KeyEvent e) {
+    	if (e.getKeyCode() == KeyEvent.VK_UNDEFINED) return;
+    	_keyDown[e.getKeyCode()] =true;
+    }
+
+    /**
+     * Invoked when a key has been released.
+     */
+    public void keyReleased(KeyEvent e) {
+    	if (e.getKeyCode() == KeyEvent.VK_UNDEFINED) return;
+    	_keyDown[e.getKeyCode()] =false;;
+    }
+    
+    protected boolean isKeyDown(int keyCode) {
+    	return _keyDown[keyCode];
+    }
+}
-- 
2.8.4 (Apple Git-73)

